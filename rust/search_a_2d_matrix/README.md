# 74. Search a 2D Matrix (Rust)

## Problem
You are given an `m x n` integer matrix in which each row is sorted in non-decreasing order and the first element of each row is greater than the last element of the previous row. Given a `target` value, return `true` if `target` is present anywhere in the matrix or `false` otherwise. The expected runtime is `O(log(m * n))`.

## Examples
- **Example 1**
  - Input: `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]`, `target = 3`
  - Output: `true`
- **Example 2**
  - Input: `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]`, `target = 13`
  - Output: `false`

## Edge Cases and Long Examples
- Single-cell matrices containing or missing the target (`[[5]]`, target `5` ? `true`; target `1` ? `false`).
- Matrices that include empty rows when represented in jagged form.
- Tall matrices (many rows) and wide matrices (many columns) to ensure both dimensions are handled properly.
- Large matrices generated by the harness (50x50 with step size 2) to stress the logarithmic search.

## Constraints
- `1 <= m, n <= 100`
- `-10^4 <= matrix[i][j], target <= 10^4`
- The matrix satisfies the row-ordering properties described above.

## Implementation Notes
- Implement `Solution::search_matrix` using binary search to locate the potential row and then the element.
- `src/main.rs` defines multiple scenarios, measures execution time with four-decimal-millisecond precision, and prints the returned result (or panic message) alongside the expectations. The solution currently uses `todo!()` so you can implement the algorithm yourself.
